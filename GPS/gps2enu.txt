    bool
DJISDKNode::setLocalPosRefCallback(dji_sdk::SetLocalPosRef::Request &request,
                                     dji_sdk::SetLocalPosRef::Response &response) {
  printf("Currrent GPS health is %d \n",current_gps_health );
  if (current_gps_health > 3)
  {
    local_pos_ref_latitude = current_gps_latitude;
    local_pos_ref_longitude = current_gps_longitude;
    local_pos_ref_altitude = current_gps_altitude;
    ROS_INFO("Local Position reference has been set.");
    ROS_INFO("MONITOR GPS HEALTH WHEN USING THIS TOPIC");
    local_pos_ref_set = true;

    // Create message to publish to a topic
    sensor_msgs::NavSatFix localFrameLLA;
    localFrameLLA.latitude = local_pos_ref_latitude;
    localFrameLLA.longitude = local_pos_ref_longitude;
    localFrameLLA.altitude = local_pos_ref_altitude;
    local_frame_ref_publisher.publish(localFrameLLA);

    response.result = true;
  }
    
    
    {
      geometry_msgs::PointStamped local_pos;
      local_pos.header.frame_id = "/local";
      local_pos.header.stamp = now_time;
      gpsConvertENU(local_pos.point.x, local_pos.point.y, gps_pos.longitude,
                       gps_pos.latitude, this->local_pos_ref_longitude, this->local_pos_ref_latitude);
      local_pos.point.z = gps_pos.altitude - this->local_pos_ref_altitude;
      /*!
      * note: We are now following REP 103 to use ENU for
      *       short-range Cartesian representations. Local position is published
      *       in ENU Frame
      */

      this->local_position_publisher.publish(local_pos);
    }
      
      
      
      
      
      void DJISDKNode::gpsConvertENU(double &ENU_x, double &ENU_y,
                                 double gps_t_lon, double gps_t_lat,
                                 double gps_r_lon, double gps_r_lat)
{
  double d_lon = gps_t_lon - gps_r_lon;
  double d_lat = gps_t_lat - gps_r_lat;
  ENU_y = DEG2RAD(d_lat) * C_EARTH;
  ENU_x = DEG2RAD(d_lon) * C_EARTH * cos(DEG2RAD(gps_t_lat));
};

